const fs = require('fs').promises;
const path = require('path');

// Path to the core data model directory (read-only)
const CORE_MODEL_DIR = path.join(__dirname, '../../core/data model');

// Path to client data model directory (read-write)
// Use absolute path from project root instead of relative path
const CLIENT_MODEL_DIR = path.join(process.cwd(), 'core/data-model');

// Ensure client model directory exists
async function ensureClientModelDir() {
  await fs.mkdir(CLIENT_MODEL_DIR, { recursive: true });
}

// Check if a model is a core model (protected)
async function isProtectedModel(modelId) {
  try {
    const filePath = path.join(CORE_MODEL_DIR, `${modelId}.js`);
    await fs.access(filePath);
    return true;
  } catch (err) {
    return false;
  }
}

// Get all data models from both locations
async function fetchDataModels() {
  await ensureClientModelDir();
  try {
    // Get core models
    const coreFiles = await fs.readdir(CORE_MODEL_DIR);
    const coreModelFiles = coreFiles.filter(file => file.endsWith('.js'));
    
    // Get client models
    const clientFiles = await fs.readdir(CLIENT_MODEL_DIR);
    const clientModelFiles = clientFiles.filter(file => file.endsWith('.js'));
    
    // Process both sets of models
    const coreModels = await Promise.all(coreModelFiles.map(async (file) => {
      const modelPath = path.join(CORE_MODEL_DIR, file);
      delete require.cache[require.resolve(modelPath)];
      const model = require(modelPath);
      return {
        id: model.id,
        label: model.label,
        description: model.description || '',
        extends: model.extends || null,
        isProtected: true // Mark as protected
      };
    }));
    
    const clientModels = await Promise.all(clientModelFiles.map(async (file) => {
      const modelPath = path.join(CLIENT_MODEL_DIR, file);
      delete require.cache[require.resolve(modelPath)];
      const model = require(modelPath);
      return {
        id: model.id,
        label: model.label,
        description: model.description || '',
        extends: model.extends || null,
        isProtected: false // Mark as editable
      };
    }));
    
    return [...coreModels, ...clientModels];
  } catch (err) {
    console.error('Error fetching data models:', err);
    throw err;
  }
}

// Get a specific data model by ID (checks both locations)
async function fetchDataModel(dataModelId) {
  await ensureClientModelDir();
  try {
    // Look for the model in client directory first
    let model = null;
    let isProtected = false;
    
    try {
      const clientPath = path.join(CLIENT_MODEL_DIR, `${dataModelId}.js`);
      delete require.cache[require.resolve(clientPath)];
      model = require(clientPath);
    } catch (err) {
      // If not found in client dir, check core dir
      try {
        const corePath = path.join(CORE_MODEL_DIR, `${dataModelId}.js`);
        delete require.cache[require.resolve(corePath)];
        model = require(corePath);
        isProtected = true;
      } catch (err) {
        return null; // Not found in either location
      }
    }
    
    // If model extends another model, merge the attributes
    if (model && model.extends) {
      const baseModel = await fetchDataModel(model.extends);
      if (baseModel) {
        // Merge attributes from base model
        const baseAttributes = baseModel.attributes || [];
        const modelAttributes = model.attributes || [];
        
        // Create a new array with base attributes followed by model attributes
        model.attributes = [...baseAttributes, ...modelAttributes];
        
        // Also merge hooks if present
        if (baseModel.hooks) {
          model.hooks = { ...(baseModel.hooks || {}), ...(model.hooks || {}) };
        }
      }
    }
    
    // Add protection flag
    if (model) {
      model.isProtected = isProtected;
    }
    
    return model;
  } catch (err) {
    console.error(`Error fetching data model ${dataModelId}:`, err);
    throw err;
  }
}

// Create a new data model (always in client directory)
async function createDataModel(modelData) {
  await ensureClientModelDir();
  const { id, label, description = '', extends: extendModel = null, attributes = [], isEditable = true } = modelData;
  
  try {
    // Check if model already exists in either location
    if (await isProtectedModel(id)) {
      throw new Error(`Cannot create model: '${id}' is a protected core model`);
    }
    
    const clientPath = path.join(CLIENT_MODEL_DIR, `${id}.js`);
    try {
      await fs.access(clientPath);
      throw new Error(`Data model with ID ${id} already exists`);
    } catch (err) {
      // File doesn't exist, we can create it
    }
    
    // Create model content
    const modelContent = `module.exports = {
  id: '${id}',
  label: '${label}',
  description: '${description}',
  ${extendModel ? `extends: '${extendModel}',` : ''}
  isEditable: ${isEditable},
  attributes: ${JSON.stringify(attributes, null, 2).replace(/"([^"]+)":/g, '$1:')}
};`;
    
    // Write model to client file
    await fs.writeFile(clientPath, modelContent);
    
    const newModel = await fetchDataModel(id);
    return newModel;
  } catch (err) {
    console.error(`Error creating data model ${id}:`, err);
    throw err;
  }
}

// Update an existing data model (only if it's in client directory)
async function updateDataModel(dataModelId, updateData) {
  await ensureClientModelDir();
  try {
    // First check if this is a protected model
    if (await isProtectedModel(dataModelId)) {
      throw new Error(`Cannot update protected model: ${dataModelId}`);
    }
    
    // Fetch the existing model
    const model = await fetchDataModel(dataModelId);
    
    if (!model) {
      throw new Error(`Data model ${dataModelId} is not found or uneditable: `);
    }
    
    // Update model properties
    const updatedModel = {
      ...model,
      ...updateData,
      id: dataModelId // Ensure ID remains unchanged
    };
    
    // Create model content
    const modelContent = `module.exports = {
  id: '${updatedModel.id}',
  label: '${updatedModel.label}',
  description: '${updatedModel.description || ''}',
  ${updatedModel.extends ? `extends: '${updatedModel.extends}',` : ''}
  attributes: ${JSON.stringify(updatedModel.attributes || [], null, 2).replace(/"([^"]+)":/g, '$1:')}
  ${updatedModel.hooks ? `,\n  hooks: ${JSON.stringify(updatedModel.hooks, null, 2).replace(/"([^"]+)":/g, '$1:')}` : ''}
};`;
    
    // Write model to client file
    const filePath = path.join(CLIENT_MODEL_DIR, `${dataModelId}.js`);
    await fs.writeFile(filePath, modelContent);
    
    return await fetchDataModel(dataModelId);
  } catch (err) {
    console.error(`Error updating data model ${dataModelId}:`, err);
    throw err;
  }
}

// Delete a data model (only if it's in client directory)
async function deleteDataModel(dataModelId) {
  await ensureClientModelDir();
  try {
    // First check if this is a protected model
    if (await isProtectedModel(dataModelId)) {
      throw new Error(`Cannot delete protected model: ${dataModelId}`);
    }
    
    const filePath = path.join(CLIENT_MODEL_DIR, `${dataModelId}.js`);
    
    // Check if file exists
    try {
      await fs.access(filePath);
    } catch (err) {
      throw new Error(`Data model not found: ${dataModelId}`);
    }
    
    // Delete the file
    await fs.unlink(filePath);
    
    return { success: true };
  } catch (err) {
    console.error(`Error deleting data model ${dataModelId}:`, err);
    throw err;
  }
}

// Delete an attribute from a data model (only if it's in client directory)
async function deleteDataModelAttribute(dataModelId, attributeId) {
  await ensureClientModelDir();
  try {
    // First check if this is a protected model
    if (await isProtectedModel(dataModelId)) {
      throw new Error(`Cannot modify protected model: ${dataModelId}`);
    }
    
    // Fetch the existing model
    const model = await fetchDataModel(dataModelId);
    
    if (!model) {
      const error = new Error(`Data model not found: ${dataModelId}`);
      error.statusCode = 404;
      throw error;
    }
    
    // Check if model has attributes
    if (!model.attributes || !Array.isArray(model.attributes)) {
      const error = new Error(`Data model '${dataModelId}' does not have any attributes`);
      error.statusCode = 400;
      throw error;
    }
    
    // Find the attribute to delete
    const attributeIndex = model.attributes.findIndex(attr => attr.id == attributeId);
    console.log(model.attributes);
    if (attributeIndex === -1) {
      const error = new Error(`Attribute '${attributeId}' not found in data model '${dataModelId}'`);
      error.statusCode = 404;
      throw error;
    }
    
    // If the attribute is required, prevent deletion
    if (model.attributes[attributeIndex].required) {
      const error = new Error(`Cannot delete required attribute '${attributeId}'`);
      error.statusCode = 400;
      throw error;
    }
    
    // Remove the attribute
    model.attributes.splice(attributeIndex, 1);
    
    // Get the client file path
    const filePath = path.join(CLIENT_MODEL_DIR, `${dataModelId}.js`);
    
    // Generate updated model content
    const modelContent = `module.exports = {
  id: '${model.id}',
  label: '${model.label}',
  description: '${model.description || ''}',
  ${model.extends ? `extends: '${model.extends}',` : ''}
  attributes: ${JSON.stringify(model.attributes || [], null, 2).replace(/"([^"]+)":/g, '$1:')}
  ${model.hooks ? `,\n  hooks: ${JSON.stringify(model.hooks, null, 2).replace(/"([^"]+)":/g, '$1:')}` : ''}
};`;
    
    // Write updated model to client file
    await fs.writeFile(filePath, modelContent);
    
    // Return the updated model
    return await fetchDataModel(dataModelId);
  } catch (err) {
    console.error(`Error deleting attribute ${attributeId} from model ${dataModelId}:`, err);
    throw err;
  }
}

// Add a new attribute to a data model (only if it's in client directory)
async function addDataModelAttribute(dataModelId, attributeData) {
  await ensureClientModelDir();
  try {
    // First check if this is a protected model
    if (await isProtectedModel(dataModelId)) {
      throw new Error(`Cannot modify protected model: ${dataModelId}`);
    }
    
    // Fetch the existing model
    const model = await fetchDataModel(dataModelId);
    
    if (!model) {
      const error = new Error(`Data model not found: ${dataModelId}`);
      error.statusCode = 404;
      throw error;
    }
    
    // Initialize attributes array if it doesn't exist
    if (!model.attributes) {
      model.attributes = [];
    } else if (!Array.isArray(model.attributes)) {
      model.attributes = [];
    }
    
    // Check if attribute with same ID already exists
    const existingAttrIndex = model.attributes.findIndex(attr => attr.id === attributeData.id);
    if (existingAttrIndex !== -1) {
      const error = new Error(`Attribute with ID '${attributeData.id}' already exists in model '${dataModelId}'`);
      error.statusCode = 400;
      throw error;
    }
    
    // Add the new attribute
    model.attributes.push(attributeData);
    
    // Get the client file path
    const filePath = path.join(CLIENT_MODEL_DIR, `${dataModelId}.js`);
    
    // Generate updated model content
    const modelContent = `module.exports = {
  id: '${model.id}',
  label: '${model.label}',
  description: '${model.description || ''}',
  ${model.extends ? `extends: '${model.extends}',` : ''}
  ${model.isEditable !== undefined ? `isEditable: ${model.isEditable},` : ''}
  attributes: ${JSON.stringify(model.attributes, null, 2).replace(/"([^"]+)":/g, '$1:')}
  ${model.hooks ? `,\n  hooks: ${JSON.stringify(model.hooks, null, 2).replace(/"([^"]+)":/g, '$1:')}` : ''}
};`;
    
    // Write updated model to client file
    await fs.writeFile(filePath, modelContent);
    
    // Return the updated model
    return await fetchDataModel(dataModelId);
  } catch (err) {
    console.error(`Error adding attribute to model ${dataModelId}:`, err);
    throw err;
  }
}

module.exports = {
  fetchDataModels,
  fetchDataModel,
  createDataModel,
  updateDataModel,
  deleteDataModel,
  deleteDataModelAttribute,
  addDataModelAttribute,
  isProtectedModel
};