const fs = require('fs');
const path = require('path');

// Helper function to check if the directory exists and is accessible
const checkDirectoryAccess = (directoryPath) => {
    return new Promise((resolve, reject) => {
        fs.access(directoryPath, fs.constants.R_OK, (err) => {
            if (err) {
                return reject(`Directory not found or inaccessible: ${directoryPath}`);
            }
            resolve();
        });
    });
};

// Helper function to read the directory contents
const readDirectory = (directoryPath) => {
    return new Promise((resolve, reject) => {
        fs.readdir(directoryPath, (err, files) => {
            if (err) {
                return reject(`Unable to read case types: ${err.message}`);
            }

            if (!files || files.length === 0) {
                return resolve([]); // Return an empty array if no files are found
            }

            resolve(files);
        });
    });
};

// Function to get all case types
const getComponents = () => {
    const componentDirectory = path.join(process.cwd(), '/client/src/component');

    return checkDirectoryAccess(componentDirectory)
        .then(() => readDirectory(componentDirectory))
        .then((files) => {
            // Remove file extensions and return file names only
            return files.map(file => {
                const componentName = path.parse(file).name; // Extract the file name without extension
                return { fileName: componentName }; // Only return the file name
            });
        })
        .catch((error) => {
            throw new Error(error);
        });
};




const getComponent = (componentName) => {
    const componentDirectory = path.join(process.cwd(), '/client/src/component');

    return checkDirectoryAccess(componentDirectory)
        .then(() => readDirectory(componentDirectory))
        .then((files) => {
            const matchingFile = files.find(file => path.parse(file).name === componentName);

            if (!matchingFile) {
                return `Component not found for name: ${componentName}`;
            }

            // Read the file content instead of requiring it
            const componentPath = path.join(componentDirectory, matchingFile);
            try {
                const componentContent = fs.readFileSync(componentPath, 'utf-8'); // Read the file content
                return componentContent; // Return the file content
            } catch (err) {
                return `Error reading component: ${err.message}`; // Gracefully return the error
            }
        })
        .catch((error) => {
            return `Error accessing directory or reading files: ${error.message}`;
        });
};

const createComponent = (componentName, content) => {
  const componentDirectory = path.join(process.cwd(), '/client/src/component');
  const filePath = path.join(componentDirectory, `${componentName}.js`);

  // Check if the file already exists
  if (fs.existsSync(filePath)) {
    return Promise.reject(new Error('Component already exists'));
  }

  // Write the new file
  return fs.promises.writeFile(filePath, content, 'utf8')
    .then(() => 'Component created successfully')
    .catch((err) => {
      throw new Error(`Error creating component: ${err.message}`);
    });
};

const updateComponent = (componentName, content) => {
  const componentDirectory = path.join(process.cwd(), '/client/src/component');
  const filePath = path.join(componentDirectory, `${componentName}.js`);

  // Check if the file exists
  if (!fs.existsSync(filePath)) {
    return Promise.reject(new Error('Component not found'));
  }

  // Update the file
  return fs.promises.writeFile(filePath, content, 'utf8')
    .then(() => 'Component updated successfully')
    .catch((err) => {
      throw new Error(`Error updating component: ${err.message}`);
    });
};


module.exports = { getComponents, getComponent, createComponent, updateComponent };
//component repository